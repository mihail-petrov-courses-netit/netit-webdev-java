## $какво разгледахме днес ?
- упражнение
- мистериозния клас - Object
- цикъл for за работа с колекции

## $задачи за упражнения
- [Работа в час](https://github.com/mihail-petrov/netit-webdev-java/tree/master/2022-2023/%40semester_1/week-09-2/cw)
<!-- - [Домашна работа](https://github.com/mihail-petrov/netit-webdev-java/tree/master/2022-2023/%40semester_1/week-09-1/hw) -->

## $други ресурси
- [видео](https://drive.google.com/file/d/1SxeZMTGEEeQsrTIE6pwPX-okuqSig9v6/view?usp=sharing)
- [сорс код](https://github.com/mihail-petrov/netit-webdev-java/tree/master/2022-2023/%40semester_1/week-09-2/source)

## Мистериозния клас Object

В приключението ни до момента се натъкнахме на една специфична особеност на обектите, която ни накара объркано да се почесваме по главата, докато се опитваме да си обясним защо, се получава така - говорим за мистериозните методи, които нашия любим InteliJ ни предоставя за употреба, без ние по какъвто и да е било начин да сме станали причина за тяхното съществуване. 

Нека разгледаме следния пример. Ще си направим клас **Event** , който няма да съдържа нито един метод.

```java
class Money {
    private int currensy;
    private String ammount;
}
```

Ще направим - инстанция на класа Money

```java
Money account = new Money();
```

Ако опитаме да ползваме оператора **. (точка)** , ще установим че имаме достъп до някой интересни методи, които се появяват сякаш от нищото.

![](2022-05-06-11-21-30.png)

Някой от тях включват:
- equals
- hashCode
- toString
- getClass
- notify
- notifyAll
- wait

От къде идват тези методи и каква е тяхната роля в историята ни до момента? Java пази една голяма тайна. Всеки един от класовете, които създадохме до момента, включително и тези които сме заварили (написани от Java разработчиците) имат специален ръководител, който се крие в сенките. Това е системния клас **Object**. Това е специален клас който дава набор от методи на всички останали класове в системата.

**Пример**

Метода **toString** - съдържа логика, която връща низ, при опит да стрингосаме, инстанцията на произволен обект. Вярно резултата е скучен и напълно нечетим, но за сметка на това решава проблем, който е генерален за всички потретибелски дефинирани типове - липсата на общ подход към решението на този проблем.

Метода **equals** - с който вече сме запознати, решава проблема с това как да сравним два обекта, Обектите съдържат в себе си множество данни и тяхното сравнение не е лесна операция. 

Разбира се, ако имаме желание да решим някой от тези проблеми, можем да презапишем дифолтната логика, на метода и да я моделираме спрямо нашите нужди. 

**Пример**

Ако се опитаме да визуализираме, инстанцията на класа **Money**, която направихме.

```java
System.out.print(account);
```

Ще получим следния странен резултат

```java
Money@27ds4fdffg
```

Този резултат, ще бъде различен всеки път когато стартираме програмата. Резултата съдържа името на класа и адреса в паметта, в която е създаден обекта. Звучи компютърно но без достатъчно смисъл за нас. Доста по подходящо би било да видим резултат съдържащ данните на класа. 

Нека разширим логиката в класа Money като добавим конструктор и метода toString - в който ще разпишем логика за визуализация на неговите полета. 

```java
class Money {
    private int currensy;
    private String ammount;

    public Money(String currensy, double ammount) {
        this.currensy   = currensy;
        this.ammount    = ammount;
    }

    public String toString() {
        return this.currensy + " " + this.ammount;
    }
}
```

Резултата от тази промяна, до голяма степен е очакван

```java
Money account = new Money("BGN", 12.5);
System.out.print(account)
// BGN 12.5
```

Операцията по презаписване на логиката на toString е известна като **overwriting** предстоят ни още много примери, свързани с нея. 

## Цикъл for за работа с колекции

Нека добавим още един помощен инструмент в арсенала си. Когато **for** цикъла се появи в живота ни осъзнахме, че лесно можем да използваме супер силите му за да обикаляме из елементите на масивите. 

```java

int[] collection = new int[3];
collection[0] = 10;
collection[1] = 20;
collection[2] = 30;

for(int i = 0; i < collection.length; i++) {

    int element = collection[i];
    System.out.print(element);
}
```

Осъзнаваме, гледайти примера че голяма част от операциите които извършваме с масивите са свързани с :
- изцикляне на всички елементи в масива 
- взимане на елемент от масива с помоща на оператора **[]**

Добрата Java ни дава възможност, да елиминираме част от кода, който пишем механично:
- i < collection.length
- int element = collection[i];

Нека ви представим - for за работа с колекции без броячи

```java
for(int element : collection) {
    System.out.print(element);
}
```

Ползвайте го разумно :)